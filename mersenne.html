<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mersenne Prime Data Analyzer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .button-group {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #3498db;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        .results-section {
            display: none;
        }

        .filter-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .filter-controls input[type="checkbox"] {
            cursor: pointer;
        }

        .filter-controls select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th:hover {
            background: #e9ecef;
        }

        th .sort-indicator {
            float: right;
            color: #999;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .factored {
            color: #27ae60;
        }

        .unfactored {
            color: #e74c3c;
        }

        .yes {
            color: #27ae60;
            font-weight: 500;
        }

        .no {
            color: #e74c3c;
            font-weight: 500;
        }

        .tf-level {
            font-family: 'Courier New', monospace;
            font-weight: 500;
        }

        .tf-notes {
            font-size: 11px;
            color: #e67e22;
            font-style: italic;
        }

        .error {
            background: #fee;
            border: 1px solid #fcc;
            padding: 15px;
            border-radius: 5px;
            color: #c00;
            margin-top: 20px;
        }

        .info-box {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .distribution-table {
            margin-top: 20px;
        }

        .distribution-table table {
            max-width: 400px;
        }

        .tf-assignment-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .tf-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .tf-controls input[type="number"] {
            width: 100px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .worktodo-output {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .copy-button {
            float: right;
            padding: 5px 10px;
            font-size: 12px;
        }

        .exponent-link {
            color: #3498db !important;
            text-decoration: none !important;
        }

        .exponent-link:hover {
            text-decoration: underline !important;
            color: #2980b9 !important;
        }

        .user-stats-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .user-stats-table {
            font-size: 14px;
        }

        .user-stats-table th {
            font-size: 12px;
            padding: 8px;
        }

        .user-stats-table td {
            padding: 8px;
        }

        .user-name {
            font-weight: 500;
            color: #2c3e50;
        }

        .stat-number {
            font-family: 'Courier New', monospace;
            font-weight: 500;
        }

        .section-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab-button {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 16px;
            color: #7f8c8d;
            transition: all 0.3s;
        }

        .tab-button.active {
            color: #2c3e50;
            border-bottom-color: #3498db;
        }

        .tab-button:hover {
            color: #2c3e50;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .clickable-factor {
            cursor: pointer;
            color: #3498db;
            text-decoration: underline;
        }

        .clickable-factor:hover {
            color: #2980b9;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .modal-close:hover {
            color: #333;
        }

        .factor-list {
            list-style: none;
            padding: 0;
        }

        .factor-list li {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .factor-list li:last-child {
            border-bottom: none;
        }

        .factor-exponent {
            font-weight: 500;
        }

        .factor-value {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #666;
            word-break: break-all;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            table {
                font-size: 14px;
            }

            th,
            td {
                padding: 8px;
            }

            .user-stats-table {
                font-size: 12px;
            }

            .user-stats-table th,
            .user-stats-table td {
                padding: 6px;
            }

            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z" />
                <path d="M12 8v8" />
                <path d="M8 12h8" />
            </svg>
            Mersenne Prime Data Analyzer
        </h1>
        <p class="subtitle">Parse and analyze GIMPS HTML exponent data with user activity tracking</p>

        <div class="input-section">
            <div class="info-box">
                <strong>Instructions:</strong> Go to the <a href="https://www.mersenne.org/report_exponent/">GIMPS PrimeNet Exponent Status page</a>, select your exponent
                range,
                choose "Output results in HTML format", "Show full details", "Include full ECM history", and "Include Ancient History logs" 
                Then copy the page content (Ctrl+A,
                Ctrl+C)
                and paste it below. The tool will parse the text data from the HTML page.
                <br><br>
                <strong>Note:</strong> ECM limits indicate the level below which trial factoring is very unlikely to
                find new factors due to extensive ECM work already performed.
                <br><br>
                <strong>Note:</strong> Please sign up for a range at <a href="https://www.mersenneforum.org/node/1062086">mersenneforum.org</a>.
                Please do not just randomly start factoring exponents without coordination.
            </div>

            <textarea id="dataInput" placeholder="Paste your GIMPS HTML data here..."></textarea>

            <div class="button-group">
                <button class="btn-primary" onclick="parseData()">Parse Data</button>
                <button class="btn-secondary" onclick="clearData()">Clear</button>
                <button class="btn-secondary" onclick="loadExample()">Load Example</button>
            </div>
        </div>

        <div class="results-section" id="results">
            <h2>Analysis Results</h2>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="statTotal">0</div>
                    <div class="stat-label">Total Exponents</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statFactored">0</div>
                    <div class="stat-label">Factored</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statP1">0</div>
                    <div class="stat-label">P-1 Complete</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statPRP">0</div>
                    <div class="stat-label">PRP/LL Complete</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statUniqueUsers">0</div>
                    <div class="stat-label">Active Users</div>
                </div>
            </div>

            <div class="section-tabs">
                <button class="tab-button active" onclick="showTab('exponents')">Exponent Details</button>
                <button class="tab-button" onclick="showTab('users')">User Activity</button>
                <button class="tab-button" onclick="showTab('assignments')">TF Assignments</button>
            </div>

            <div id="exponents-tab" class="tab-content active">
                <div class="distribution-table">
                    <h3>TF Level Distribution</h3>
                    <table id="tfDistribution">
                        <thead>
                            <tr>
                                <th>TF Level</th>
                                <th>Count</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>

                <h3 style="margin-top: 30px;">Detailed Results</h3>

                <div class="filter-controls">
                    <label>
                        <input type="checkbox" id="filterUnfactored" onchange="applyFilters()">
                        Show only unfactored
                    </label>
                    <label>
                        <input type="checkbox" id="filterNoP1" onchange="applyFilters()">
                        Show only missing P-1
                    </label>
                    <label>
                        <input type="checkbox" id="filterNoPRP" onchange="applyFilters()">
                        Show only missing PRP/LL
                    </label>
                    <select id="tfLevelFilter" onchange="applyFilters()">
                        <option value="">All TF Levels</option>
                    </select>
                </div>

                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th onclick="sortTable(0)">Exponent <span class="sort-indicator">▼</span></th>
                            <th onclick="sortTable(1)">TF Level <span class="sort-indicator"></span></th>
                            <th>TF Notes</th>
                            <th onclick="sortTable(3)">P-1 Done <span class="sort-indicator"></span></th>
                            <th onclick="sortTable(4)">PRP/LL Done <span class="sort-indicator"></span></th>
                            <th onclick="sortTable(5)">Status <span class="sort-indicator"></span></th>
                            <th>Factors</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <div id="users-tab" class="tab-content">
                <div class="user-stats-section">
                    <h3>User Activity Statistics</h3>
                    <p style="margin-bottom: 15px;">Activity breakdown for all users who have worked on exponents in this range.</p>

                    <table id="userStatsTable" class="user-stats-table">
                        <thead>
                            <tr>
                                <th onclick="sortUserTable(0)">User <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(1)">TF Exponents <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(2)">TF Levels Done <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(3)">TF Factors Found <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(4)">P-1 Exponents <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(5)">P-1 Factors Found <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(6)">PRP/LL Tests <span class="sort-indicator"></span></th>
                                <th onclick="sortUserTable(7)">Total Activity <span class="sort-indicator"></span></th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div id="assignments-tab" class="tab-content">
                <div class="tf-assignment-section">
                    <h3>Generate TF Assignments</h3>
                    <p style="margin-bottom: 15px;">Generate worktodo entries for trial factoring unfactored exponents.</p>

                    <div class="tf-controls">
                        <label>
                            Target TF Level: 2^
                            <input type="number" id="tfTargetLevel" value="73" min="68" max="100">
                        </label>
                        <button class="btn-primary" onclick="generateTFAssignments()">Generate Assignments</button>
                        <label>
                            <input type="checkbox" id="includeFactored" onchange="generateTFAssignments()">
                            Include factored exponents
                        </label>
                    </div>

                    <div id="worktodoContainer" style="display: none;">
                        <div style="position: relative;">
                            <button class="btn-secondary copy-button" onclick="copyWorktodo()">Copy to Clipboard</button>
                            <h4>Worktodo Entries:</h4>
                        </div>
                        <div class="worktodo-output" id="worktodoOutput"></div>
                    </div>
                    
                    <div id="tfErrorMessage"></div>
                </div>
            </div>
        </div>

        <div id="errorMessage"></div>
        
        <!-- Factor Details Modal -->
        <div id="factorModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modalTitle">Factor Details</h3>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <ul id="factorList" class="factor-list"></ul>
            </div>
        </div>
    </div>

    <script>
        let parsedData = {};
        let userStats = {};
        let currentSort = { column: 0, ascending: true };
        let currentUserSort = { column: 7, ascending: false };

        function parseHTMLData(textData) {
            const results = {};
            const lines = textData.split('\n');

            let currentExponent = null;
            let currentSection = null;
            let i = 0;

            while (i < lines.length) {
                const line = lines[i].trim();

                // Skip empty lines
                if (!line) {
                    i++;
                    continue;
                }

                // Check for exponent line (starts with number followed by tab and status description)
                const expMatch = line.match(/^(\d+)\t(Composite|Prime|PRP|Status|Tested)/);
                if (expMatch) {
                    currentExponent = parseInt(expMatch[1]);

                    // Initialize exponent data
                    results[currentExponent] = {
                        exponent: currentExponent,
                        tfLevel: 68, // Default minimum
                        ecmTfLimit: null, // ECM-based TF limit
                        incompleteRange: null, // Track incomplete TF ranges
                        p1Done: false,
                        prpOrLlDone: false,
                        isFactored: false,
                        factors: [],
                        allData: []
                    };

                    // Check status for factored/composite
                    const status = line.substring(expMatch[1].length + 1);
                    if (status.toLowerCase().includes('composite')) {
                        // Only mark as factored if it explicitly mentions factors
                        if (status.toLowerCase().includes('known prime factor')) {
                            results[currentExponent].isFactored = true;
                        }
                    }

                    // Check for PRP/LL proven
                    if (status.toLowerCase().includes('proven not-prime')) {
                        results[currentExponent].prpOrLlDone = true;
                    }

                    currentSection = null;
                    i++;
                    continue;
                }

                // Check for section headers (they appear alone on a line, possibly with trailing whitespace)
                const sectionMatch = line.match(/^(Factored|TF|P-1|LL|PRP|History|ECM|P-1 factors|PRP Cofactor)\s*$/);
                if (currentExponent && sectionMatch) {
                    currentSection = sectionMatch[1];
                    i++;
                    continue;
                }

                // Check if we've hit a new exponent or end of data
                if (line.match(/^(\d+)\t(Composite|Prime|PRP|Status)/) || line.includes('©') || line.startsWith('Current time:')) {
                    // Reset for new exponent (don't increment i, let the main loop handle this line)
                    currentExponent = null;
                    currentSection = null;
                    i++;
                    continue;
                }

                // Parse section content
                if (currentExponent && currentSection) {
                    // Check for ECM TF limit across all sections
                    const ecmTfMatch = line.match(/TF below 2\^(\d+) is very unlikely to find new factors due to ECM effort/);
                    if (ecmTfMatch) {
                        results[currentExponent].ecmTfLimit = parseInt(ecmTfMatch[1]);
                    }

                    // Skip header lines
                    if ((line.includes('Status') && line.includes('Date') && line.includes('User')) ||
                        (line.includes('Factor') && line.includes('Digits') && line.includes('Bits')) ||
                        (line.includes('Date') && line.includes('User') && line.includes('Type') && line.includes('Result'))) {
                        i++;
                        continue;
                    }

                    if (currentSection === 'TF') {
                        // Look for "No factors below 2^X"
                        const tfMatch = line.match(/No factors below 2\^(\d+)/);
                        if (tfMatch) {
                            results[currentExponent].tfLevel = parseInt(tfMatch[1]);
                        }
                    } else if (currentSection === 'P-1') {
                        // Look for B1/B2 values
                        const b1Match = line.match(/B1\s*=\s*(\d+)/);
                        if (b1Match && parseInt(b1Match[1]) > 0) {
                            results[currentExponent].p1Done = true;
                        }
                    } else if (currentSection === 'Factored') {
                        // Extract factors - skip if this is a header line
                        if (line === 'Factor\tDigits\tBits\tDate') {
                            i++;
                            continue;
                        }

                        const parts = line.split('\t');
                        if (parts.length >= 2 && /^\d+$/.test(parts[0])) {
                            // This is a factor line
                            results[currentExponent].factors.push(parts[0]);
                            results[currentExponent].isFactored = true;
                        }
                    } else if (currentSection === 'LL' || currentSection === 'PRP') {
                        // Check for verification
                        if (line.startsWith('Verified')) {
                            results[currentExponent].prpOrLlDone = true;
                        }
                    } else if (currentSection === 'History') {
                        // Skip header line
                        if (line === 'Date\tUser\tType\tResult') {
                            i++;
                            continue;
                        }

                        // Parse history entries
                        const parts = line.split('\t');

                        if (parts.length >= 3 && parts[0].match(/^\d{4}-\d{2}-\d{2}$/)) {
                            const date = parts[0];
                            const user = parts[1];
                            const type = parts[2];

                            // Initialize result from the same line
                            let result = '';

                            // Check if there's a result on this line (4th column might exist but be empty)
                            if (parts.length > 3) {
                                // Get everything after the 3rd column
                                result = parts.slice(3).join('\t').trim();
                            }

                            // If no meaningful result on this line, check the next line
                            if (!result && i + 1 < lines.length) {
                                const nextLine = lines[i + 1];
                                // Check if next line is indented or doesn't start with a date
                                if (nextLine && !nextLine.match(/^\d{4}-\d{2}-\d{2}\t/)) {
                                    // Check if it's not a section header or new exponent
                                    const trimmedNext = nextLine.trim();
                                    if (trimmedNext &&
                                        !trimmedNext.match(/^(Factored|TF|P-1|LL|PRP|History|ECM)\s*$/) &&
                                        !trimmedNext.match(/^\d{7,}\t/)) {
                                        result = trimmedNext;
                                        i++; // Skip the next line since we've processed it
                                    }
                                }
                            }

                            // Store the full history entry with user information
                            results[currentExponent].allData.push({
                                date: date,
                                user: user,
                                type: type,
                                result: result
                            });

                            // Check for TF in history - both in type and result
                            if (type === 'NF' || type === 'F') {
                                const tfHistMatch = result.match(/no factor from 2\^(\d+)\s+to\s+2\^(\d+)/);
                                if (tfHistMatch) {
                                    const tfTo = parseInt(tfHistMatch[2]);
                                    results[currentExponent].tfLevel = Math.max(results[currentExponent].tfLevel, tfTo);
                                }

                                // Special handling for factors with incomplete TF ranges (marked with *)
                                let asteriskHandled = false;
                                if (type === 'F') {
                                    // Check for incomplete TF ranges with asterisk (either "TF: 69-70*" or "69-70*")
                                    const factorTfMatch = result.match(/(?:TF:\s*)?(\d+)-(\d+)\*/);
                                    if (factorTfMatch) {
                                        // If there's a *, the range wasn't completed, so use the start level
                                        const tfFrom = parseInt(factorTfMatch[1]);
                                        const tfTo = parseInt(factorTfMatch[2]);
                                        results[currentExponent].tfLevel = Math.max(results[currentExponent].tfLevel, tfFrom);
                                        results[currentExponent].incompleteRange = `${tfFrom}-${tfTo}`;
                                        asteriskHandled = true;
                                    }
                                }

                                // Only process normal TF ranges if we didn't handle an asterisk case
                                if (!asteriskHandled) {
                                    const tfColonMatch = result.match(/TF:\s*(\d+)-(\d+)/);
                                    if (tfColonMatch) {
                                        const tfTo = parseInt(tfColonMatch[2]);
                                        results[currentExponent].tfLevel = Math.max(results[currentExponent].tfLevel, tfTo);
                                    }
                                }
                            }

                            // Check for P-1
                            if (type === 'NF-PM1' || type === 'F-PM1') {
                                results[currentExponent].p1Done = true;
                            }
                            // Also check if result contains B1= (sometimes P-1 info is in result)
                            if (result.includes('B1=') && result.includes('B2=')) {
                                results[currentExponent].p1Done = true;
                            }

                            // Check for PRP/LL verification
                            if (type === 'C-PRP' || type === 'C-LL' || type === 'CERT') {
                                results[currentExponent].prpOrLlDone = true;
                            }
                        }
                    }
                }

                i++;
            }

            return results;
        }

        // Post-process to check if incomplete ranges were later completed
        function checkIncompleteRanges(results) {
            for (const [exponent, data] of Object.entries(results)) {
                if (data.incompleteRange) {
                    const [incStart, incEnd] = data.incompleteRange.split('-').map(x => parseInt(x));

                    // Rule: All TF below 2^68 is considered complete due to separate project
                    if (incEnd <= 68) {
                        data.incompleteRange = null;
                        continue;
                    }

                    // Check if any later entries covered this range
                    let rangeCompleted = false;
                    for (const entry of data.allData) {
                        if ((entry.type === 'NF' || entry.type === 'F') && entry.result) {
                            // Check NF entries
                            const nfMatch = entry.result.match(/no factor from 2\^(\d+)\s+to\s+2\^(\d+)/);
                            if (nfMatch) {
                                const nfStart = parseInt(nfMatch[1]);
                                const nfEnd = parseInt(nfMatch[2]);
                                // Check if this NF entry covers the incomplete range
                                if (nfStart <= incStart && nfEnd >= incEnd) {
                                    rangeCompleted = true;
                                    break;
                                }
                            }

                            // Check F entries with TF ranges (but not with asterisks)
                            if (entry.type === 'F') {
                                const factorTfMatch = entry.result.match(/(?:TF:\s*)?(\d+)-(\d+)(?!\*)/);
                                if (factorTfMatch) {
                                    const tfStart = parseInt(factorTfMatch[1]);
                                    const tfEnd = parseInt(factorTfMatch[2]);
                                    // Check if this F entry covers the incomplete range
                                    if (tfStart <= incStart && tfEnd >= incEnd) {
                                        rangeCompleted = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // If the range was completed later, remove the incomplete flag
                    if (rangeCompleted) {
                        data.incompleteRange = null;
                    }
                }
            }
            return results;
        }

        function analyzeUserStats(data) {
            const stats = {};
            const totalExponents = Object.keys(data).length;

            for (const [exponent, expData] of Object.entries(data)) {
                for (const entry of expData.allData) {
                    const user = entry.user;
                    
                    if (!stats[user]) {
                        stats[user] = {
                            user: user,
                            tfExponents: new Set(),
                            tfLevels: 0,
                            tfFactors: 0,
                            tfFactorDetails: [],
                            p1Exponents: new Set(),
                            p1Factors: 0,
                            p1FactorDetails: [],
                            prpTests: 0,
                            totalActivity: 0
                        };
                    }

                    // Track TF activity
                    if (entry.type === 'NF' || entry.type === 'F') {
                        stats[user].tfExponents.add(exponent);

                        // Calculate TF levels done
                        const tfHistMatch = entry.result.match(/no factor from 2\^(\d+)\s+to\s+2\^(\d+)/);
                        if (tfHistMatch) {
                            const tfFrom = parseInt(tfHistMatch[1]);
                            const tfTo = parseInt(tfHistMatch[2]);
                            stats[user].tfLevels += (tfTo - tfFrom);
                        }

                        // Check for TF ranges in factor results
                        const tfColonMatch = entry.result.match(/(?:TF:\s*)?(\d+)-(\d+)/);
                        if (tfColonMatch) {
                            const tfFrom = parseInt(tfColonMatch[1]);
                            const tfTo = parseInt(tfColonMatch[2]);
                            stats[user].tfLevels += (tfTo - tfFrom);
                        }

                        // Count factors found via TF and extract factor details
                        if (entry.type === 'F' && entry.result.includes('Factor:')) {
                            stats[user].tfFactors++;
                            
                            // Extract factor from result
                            const factorMatch = entry.result.match(/Factor:\s*(\d+)/);
                            if (factorMatch) {
                                stats[user].tfFactorDetails.push({
                                    exponent: exponent,
                                    factor: factorMatch[1]
                                });
                            }
                        }
                    }

                    // Track P-1 activity
                    if (entry.type === 'NF-PM1' || entry.type === 'F-PM1') {
                        stats[user].p1Exponents.add(exponent);
                        
                        if (entry.type === 'F-PM1') {
                            stats[user].p1Factors++;
                            
                            // Try to extract P-1 factor details
                            const factorMatch = entry.result.match(/Factor:\s*(\d+)/);
                            if (factorMatch) {
                                stats[user].p1FactorDetails.push({
                                    exponent: exponent,
                                    factor: factorMatch[1]
                                });
                            }
                        }
                    }

                    // Track PRP/LL tests
                    if (entry.type === 'C-PRP' || entry.type === 'C-LL') {
                        stats[user].prpTests++;
                    }
                }
            }

            // Convert sets to counts and calculate total activity
            for (const user in stats) {
                stats[user].tfExponents = stats[user].tfExponents.size;
                stats[user].p1Exponents = stats[user].p1Exponents.size;
                stats[user].totalActivity = stats[user].tfExponents + stats[user].p1Exponents + stats[user].prpTests;
            }

            return stats;
        }

        function parseData() {
            const input = document.getElementById('dataInput').value;

            document.getElementById('results').style.display = 'none';
            document.getElementById('errorMessage').innerHTML = '';
            document.getElementById('worktodoContainer').style.display = 'none';

            if (!input.trim()) {
                showError('Please paste some data to analyze.');
                return;
            }

            try {
                parsedData = parseHTMLData(input);
                parsedData = checkIncompleteRanges(parsedData);
                userStats = analyzeUserStats(parsedData);

                if (Object.keys(parsedData).length === 0) {
                    showError('No valid data found. Please make sure you copied the HTML output from GIMPS with "Show full details" selected.');
                    return;
                }

                displayResults();
                document.getElementById('results').style.display = 'block';
                document.getElementById('errorMessage').innerHTML = '';
                document.getElementById('worktodoContainer').style.display = 'none'; // Clear previous TF assignments
            } catch (error) {
                showError('Error parsing data: ' + error.message);
                console.error('Parse error:', error);
            }
        }

        function displayResults() {
            // Calculate statistics
            let factoredCount = 0;
            let p1Count = 0;
            let prpLlCount = 0;
            let tfStats = {};

            for (const data of Object.values(parsedData)) {
                if (data.isFactored) factoredCount++;
                if (data.p1Done) p1Count++;
                if (data.prpOrLlDone) prpLlCount++;

                tfStats[data.tfLevel] = (tfStats[data.tfLevel] || 0) + 1;
            }

            const total = Object.keys(parsedData).length;
            const uniqueUsers = Object.keys(userStats).length;

            // Update stats
            document.getElementById('statTotal').textContent = total;
            document.getElementById('statFactored').textContent = factoredCount;
            document.getElementById('statP1').textContent = p1Count;
            document.getElementById('statPRP').textContent = prpLlCount;
            document.getElementById('statUniqueUsers').textContent = uniqueUsers;

            // Update TF distribution
            const tfDistBody = document.querySelector('#tfDistribution tbody');
            tfDistBody.innerHTML = '';

            const tfLevelSelect = document.getElementById('tfLevelFilter');
            tfLevelSelect.innerHTML = '<option value="">All TF Levels</option>';

            const sortedTfLevels = Object.entries(tfStats).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));

            for (const [level, count] of sortedTfLevels) {
                const row = tfDistBody.insertRow();
                row.insertCell(0).textContent = `2^${level}`;
                row.insertCell(1).textContent = count;
                row.insertCell(2).textContent = `${((count / total) * 100).toFixed(1)}%`;

                const option = document.createElement('option');
                option.value = level;
                option.textContent = `2^${level}`;
                tfLevelSelect.appendChild(option);
            }

            // Display table
            applyFilters();
            displayUserStats();
        }

        function displayUserStats() {
            const tbody = document.querySelector('#userStatsTable tbody');
            tbody.innerHTML = '';

            let userArray = Object.values(userStats);

            // Apply current user sort
            userArray.sort((a, b) => {
                let aVal, bVal;

                switch (currentUserSort.column) {
                    case 0: // User
                        aVal = a.user.toLowerCase();
                        bVal = b.user.toLowerCase();
                        break;
                    case 1: // TF Exponents
                        aVal = a.tfExponents;
                        bVal = b.tfExponents;
                        break;
                    case 2: // TF Levels
                        aVal = a.tfLevels;
                        bVal = b.tfLevels;
                        break;
                    case 3: // TF Factors
                        aVal = a.tfFactors;
                        bVal = b.tfFactors;
                        break;
                    case 4: // P-1 Exponents
                        aVal = a.p1Exponents;
                        bVal = b.p1Exponents;
                        break;
                    case 5: // P-1 Factors
                        aVal = a.p1Factors;
                        bVal = b.p1Factors;
                        break;
                    case 6: // PRP Tests
                        aVal = a.prpTests;
                        bVal = b.prpTests;
                        break;
                    case 7: // Total Activity
                        aVal = a.totalActivity;
                        bVal = b.totalActivity;
                        break;
                }

                if (typeof aVal === 'string') {
                    return currentUserSort.ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                } else {
                    if (aVal < bVal) return currentUserSort.ascending ? -1 : 1;
                    if (aVal > bVal) return currentUserSort.ascending ? 1 : -1;
                    return 0;
                }
            });

            // Display user data
            for (const user of userArray) {
                const row = tbody.insertRow();

                // User name
                const userCell = row.insertCell(0);
                userCell.textContent = user.user;
                userCell.className = 'user-name';

                // TF Exponents
                const tfExpCell = row.insertCell(1);
                tfExpCell.textContent = user.tfExponents;
                tfExpCell.className = 'stat-number';

                // TF Levels
                const tfLevelsCell = row.insertCell(2);
                tfLevelsCell.textContent = user.tfLevels;
                tfLevelsCell.className = 'stat-number';

                // TF Factors
                const tfFactorsCell = row.insertCell(3);
                if (user.tfFactors > 0) {
                    tfFactorsCell.textContent = user.tfFactors;
                    tfFactorsCell.className = 'stat-number clickable-factor';
                    tfFactorsCell.onclick = () => showFactorDetails(user.user, 'TF', user.tfFactorDetails);
                } else {
                    tfFactorsCell.textContent = user.tfFactors;
                    tfFactorsCell.className = 'stat-number';
                }

                // P-1 Exponents
                const p1ExpCell = row.insertCell(4);
                p1ExpCell.textContent = user.p1Exponents;
                p1ExpCell.className = 'stat-number';

                // P-1 Factors
                const p1FactorsCell = row.insertCell(5);
                if (user.p1Factors > 0) {
                    p1FactorsCell.textContent = user.p1Factors;
                    p1FactorsCell.className = 'stat-number clickable-factor';
                    p1FactorsCell.onclick = () => showFactorDetails(user.user, 'P-1', user.p1FactorDetails);
                } else {
                    p1FactorsCell.textContent = user.p1Factors;
                    p1FactorsCell.className = 'stat-number';
                }

                // PRP Tests
                const prpCell = row.insertCell(6);
                prpCell.textContent = user.prpTests;
                prpCell.className = 'stat-number';

                // Total Activity
                const totalCell = row.insertCell(7);
                totalCell.textContent = user.totalActivity;
                totalCell.className = 'stat-number';
            }
        }

        function applyFilters() {
            const showUnfactored = document.getElementById('filterUnfactored').checked;
            const showNoP1 = document.getElementById('filterNoP1').checked;
            const showNoPRP = document.getElementById('filterNoPRP').checked;
            const tfLevelFilter = document.getElementById('tfLevelFilter').value;

            const tbody = document.querySelector('#resultsTable tbody');
            tbody.innerHTML = '';

            let filteredData = Object.values(parsedData).filter(data => {
                if (showUnfactored && data.isFactored) return false;
                if (showNoP1 && data.p1Done) return false;
                if (showNoPRP && data.prpOrLlDone) return false;
                if (tfLevelFilter && data.tfLevel !== parseInt(tfLevelFilter)) return false;
                return true;
            });

            // Apply current sort
            filteredData.sort((a, b) => {
                let aVal, bVal;

                switch (currentSort.column) {
                    case 0: // Exponent
                        aVal = a.exponent;
                        bVal = b.exponent;
                        break;
                    case 1: // TF Level
                        aVal = a.tfLevel;
                        bVal = b.tfLevel;
                        break;
                    case 3: // P-1 Done
                        aVal = a.p1Done ? 1 : 0;
                        bVal = b.p1Done ? 1 : 0;
                        break;
                    case 4: // PRP/LL Done
                        aVal = a.prpOrLlDone ? 1 : 0;
                        bVal = b.prpOrLlDone ? 1 : 0;
                        break;
                    case 5: // Status
                        aVal = a.isFactored ? 1 : 0;
                        bVal = b.isFactored ? 1 : 0;
                        break;
                }

                if (aVal < bVal) return currentSort.ascending ? -1 : 1;
                if (aVal > bVal) return currentSort.ascending ? 1 : -1;
                return 0;
            });

            // Display filtered data
            for (const data of filteredData) {
                const row = tbody.insertRow();

                // Column 0: Exponent (clickable link)
                const expCell = row.insertCell(0);
                const expLink = document.createElement('a');
                expLink.href = `https://www.mersenne.org/M${data.exponent}`;
                expLink.textContent = data.exponent;
                expLink.target = '_blank';
                expLink.className = 'exponent-link';
                expCell.appendChild(expLink);

                // Column 1: TF Level
                const tfCell = row.insertCell(1);
                tfCell.className = 'tf-level';
                tfCell.textContent = `2^${data.tfLevel}`;

                // Column 2: TF Notes
                const tfNotesCell = row.insertCell(2);
                const notes = [];
                if (data.ecmTfLimit) {
                    notes.push(`ECM: TF below 2^${data.ecmTfLimit} unlikely`);
                }
                if (data.incompleteRange) {
                    notes.push(`Range 2^${data.incompleteRange} incomplete`);
                }
                if (notes.length > 0) {
                    tfNotesCell.textContent = notes.join('; ');
                    tfNotesCell.className = 'tf-notes';
                }

                // Column 3: P-1 Done
                const p1Cell = row.insertCell(3);
                p1Cell.textContent = data.p1Done ? 'Yes' : 'No';
                p1Cell.className = data.p1Done ? 'yes' : 'no';

                // Column 4: PRP/LL Done
                const prpCell = row.insertCell(4);
                prpCell.textContent = data.prpOrLlDone ? 'Yes' : 'No';
                prpCell.className = data.prpOrLlDone ? 'yes' : 'no';

                // Column 5: Status (Factored/Unfactored)
                const statusCell = row.insertCell(5);
                statusCell.textContent = data.isFactored ? 'Factored' : 'Unfactored';
                statusCell.className = data.isFactored ? 'factored' : 'unfactored';

                // Column 6: Factors
                const factorsCell = row.insertCell(6);
                if (data.factors.length > 0) {
                    factorsCell.textContent = data.factors.join(', ');
                    factorsCell.style.fontSize = '12px';
                    factorsCell.style.fontFamily = 'monospace';
                }
            }
        }

        function sortTable(column) {
            // Update sort indicators
            const headers = document.querySelectorAll('#resultsTable th .sort-indicator');
            headers.forEach((h, i) => {
                if (i === column) {
                    if (currentSort.column === column) {
                        currentSort.ascending = !currentSort.ascending;
                        h.textContent = currentSort.ascending ? '▼' : '▲';
                    } else {
                        currentSort.column = column;
                        currentSort.ascending = true;
                        h.textContent = '▼';
                    }
                } else {
                    h.textContent = '';
                }
            });

            applyFilters();
        }

        function sortUserTable(column) {
            // Update sort indicators
            const headers = document.querySelectorAll('#userStatsTable th .sort-indicator');
            headers.forEach((h, i) => {
                if (i === column) {
                    if (currentUserSort.column === column) {
                        currentUserSort.ascending = !currentUserSort.ascending;
                        h.textContent = currentUserSort.ascending ? '▼' : '▲';
                    } else {
                        currentUserSort.column = column;
                        currentUserSort.ascending = false; // Default to descending for numeric columns
                        h.textContent = '▲';
                    }
                } else {
                    h.textContent = '';
                }
            });

            displayUserStats();
        }

        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab and activate button
            document.getElementById(`${tabName}-tab`).classList.add('active');
            event.target.classList.add('active');
        }

        function showFactorDetails(userName, factorType, factors) {
            const modal = document.getElementById('factorModal');
            const title = document.getElementById('modalTitle');
            const factorList = document.getElementById('factorList');

            title.textContent = `${factorType} Factors Found by ${userName}`;
            factorList.innerHTML = '';

            if (factors.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No factor details available';
                factorList.appendChild(li);
            } else {
                factors.forEach(factor => {
                    const li = document.createElement('li');
                    
                    const exponentDiv = document.createElement('div');
                    const exponentLink = document.createElement('a');
                    exponentLink.href = `https://www.mersenne.org/M${factor.exponent}`;
                    exponentLink.textContent = `M${factor.exponent}`;
                    exponentLink.target = '_blank';
                    exponentLink.className = 'exponent-link factor-exponent';
                    exponentDiv.appendChild(exponentLink);
                    
                    const factorDiv = document.createElement('div');
                    factorDiv.textContent = factor.factor;
                    factorDiv.className = 'factor-value';
                    
                    li.appendChild(exponentDiv);
                    li.appendChild(factorDiv);
                    factorList.appendChild(li);
                });
            }

            modal.style.display = 'block';
        }

        function closeModal() {
            document.getElementById('factorModal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('factorModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        function clearData() {
            document.getElementById('dataInput').value = '';
            document.getElementById('results').style.display = 'none';
            document.getElementById('errorMessage').innerHTML = '';
            document.getElementById('tfErrorMessage').innerHTML = '';
            document.getElementById('worktodoContainer').style.display = 'none';
            parsedData = {};
            userStats = {};
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.getElementById('errorMessage').innerHTML = '';
            document.getElementById('errorMessage').appendChild(errorDiv);
        }

        function loadExample() {
            // Load sample data including examples of ECM limits and incomplete ranges
            const exampleData = `Marin Mersenne 2^P-1

PrimeNet Exponent Status
Exponent Range: Examples

Mn	Status	Details
17009567	Composite, with 1 known prime factor. Cofactor is composite.
Factored	
Factor	Digits	Bits	Date
1151421713510580853823	22	70.0	2019-12-06 05:09:38
ECM	
Digits	B1	Curves
25	50000	1 / 280
Estimated T-Level: 20.0 ⓘ
TF below 2^61 is very unlikely to find new factors due to ECM effort.
History	
Date	User	Type	Result
2019-12-06	masser	F	
Factor: 1151421713510580853823 / TF: 69-70*
2017-10-21	ramgeis	NF	
no factor from 2^68 to 2^69

500009	Composite, with 1 known prime factor. Cofactor is composite.
Factored	
Factor	Digits	Bits	Date
16000289	8	23.9	old
ECM	
Digits	B1	Curves
25	50000	280 / 280
30	250000	257 / 640
Estimated T-Level: 27.0 ⓘ
TF below 2^85 is very unlikely to find new factors due to ECM effort.
PRP Cofactor	
Status	Date	User	Residue	Number of
known factors	Shift	Type	Base
Verified	2024-12-04	kkmrkkblmbrbk	39CDC3C832983743	1	57640	5	3
History	
Date	User	Type	Result
2024-12-04	kkmrkkblmbrbk	C-PRP	
M500009/16000289 : 39CDC3C832983743

18000209	Composite: proven not-prime with both PRP and Lucas-Lehmer tests
TF	
No factors below 273
TF target 269
P-1	
B1 = 	4000000
B2 = 	2001838410
LL	
Status	Date	User	Residue	Shift
Verified		Martin Fahlgren	0BF47714C75FAE5E	13479122
PRP	
Status	Date	User	Residue	Shift	Type	Base
Verified	2020-08-31	Kriesel	6392E521419F6D39	0	1	3
History	
Date	User	Type	Result
2021-12-09	ZacHFX	NF	
no factor from 2^72 to 2^73
2020-08-31	Kriesel	C-PRP	
6392E521419F6D39`;
            document.getElementById('dataInput').value = exampleData;
        }

        function generateTFAssignments() {
            const targetLevel = parseInt(document.getElementById('tfTargetLevel').value);
            const includeFactored = document.getElementById('includeFactored').checked;

            if (!targetLevel || targetLevel < 68 || targetLevel > 100) {
                showTFError('Please enter a valid TF target level between 68 and 100.');
                return;
            }

            const assignments = [];

            for (const data of Object.values(parsedData)) {
                // Skip if factored and not including factored
                if (data.isFactored && !includeFactored) continue;

                // Skip if already at or above target level
                if (data.tfLevel >= targetLevel) continue;

                // Skip if ECM limit suggests TF won't be productive at target level
                if (data.ecmTfLimit && targetLevel < data.ecmTfLimit) {
                    // Still generate assignment but add a comment
                    assignments.push(`Factor=N/A,${data.exponent},${data.tfLevel},${targetLevel} ; ECM suggests TF unlikely below 2^${data.ecmTfLimit}`);
                } else {
                    // Generate normal worktodo entry: Factor=N/A,exponent,currentLevel,targetLevel
                    assignments.push(`Factor=N/A,${data.exponent},${data.tfLevel},${targetLevel}`);
                }
            }

            if (assignments.length === 0) {
                document.getElementById('worktodoContainer').style.display = 'none';
                showTFError('No exponents need TF to the specified level.');
                return;
            }

            // Display the assignments
            document.getElementById('worktodoOutput').textContent = assignments.join('\n');
            document.getElementById('worktodoContainer').style.display = 'block';

            // Clear any error messages
            document.getElementById('tfErrorMessage').innerHTML = '';
        }

        function showTFError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.getElementById('tfErrorMessage').innerHTML = '';
            document.getElementById('tfErrorMessage').appendChild(errorDiv);
        }

        function copyWorktodo() {
            const output = document.getElementById('worktodoOutput').textContent;

            // Create a temporary textarea to copy from
            const textarea = document.createElement('textarea');
            textarea.value = output;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);

            // Select and copy
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            // Update button text temporarily
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }

        // Add keyboard shortcut for parsing (Ctrl/Cmd + Enter)
        document.getElementById('dataInput').addEventListener('keydown', function (e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                parseData();
            }
        });
    </script>
</body>

</html>